// Generated by CoffeeScript 2.7.0
(function() {
  var MODELO_ARQ, angulo, atualiza_luz_material, c, getInput, gr, hex_to_vec3, id, j, job, len, ls, main, mat, phong_luzes, phong_material, pipe, prepara_instancias, prepara_pipelines, prepara_shader_groups, ref, ref1, renderiza, res;

  c = job = pipe = mat = ls = res = null;

  MODELO_ARQ = 'data/obj1.txt2';

  //MODELO_ARQ = 'data/obj2.txt2'
  gr = {
    dados_globais: null,
    dados_material: null,
    dados_instancias: null
  };

  phong_material = {
    Kamb: vec(0.4, 0.4, 0.4),
    Kdif: vec(0.7, 0.7, 0.7),
    Kspec: vec(1, 1, 1),
    shininess: 90
  };

  phong_luzes = [
    {
      params: vec(1,
    0,
    0),
      pos: vec(4,
    1,
    2),
      Lamb: hsl_to_rgb(0,
    0,
    0),
      Lspec: hex_to_rgb('#ff124f'),
      Ldif: hex_to_rgb('#fe75fe') // a luz do topo
    },
    {
      params: vec(1,
    0,
    0),
      pos: vec(-2,
    4,
    1),
      Lamb: hex_to_rgb('#120458'), // modifica mais um pouco da cor principal
      Lspec: hex_to_rgb('#7a04eb'), // cor do topo do reflexo
      Ldif: hsl_to_rgb(220,
    100,
    50) // branco da parte inferior
    },
    {
      params: vec(1,
    0,
    0),
      pos: vec(0,
    -2,
    0),
      Lamb: hex_to_rgb('#ff00a0'), // controla o meio
      Lspec: hex_to_rgb('#ff124f'), // fonte de luz
      Ldif: hsl_to_rgb(30,
    100,
    70)
    }
  ];

  angulo = 0;

  main = async() => {
    c = (await wgpu_context_new({
      canvas: 'tela',
      debug: true
    }));
    c.frame_buffer_format('color', 'depth');
    c.vertex_format('xyz', 'rgba', 'normal', 'uv');
    mat = c.use_mat4x4_format();
    res = c.resources_from_files('shader_phong.wgsl', MODELO_ARQ);
    await res.load_all();
    prepara_pipelines();
    prepara_shader_groups();
    prepara_instancias();
    job = c.job();
    return renderiza();
  };

  prepara_pipelines = function() {
    pipe = c.pipeline();
    pipe.begin('triangles');
    pipe.shader_from_src(res.text('shader_phong.wgsl'));
    pipe.depth_test(true);
    pipe.expect_group(0).binding(0).uniform();
    pipe.expect_group(1).binding(0).uniform();
    pipe.expect_group(2).binding(0).uniform_list();
    return pipe.end();
  };

  prepara_shader_groups = function() {
    var i, j, u;
    // grupo dos dados globais

    gr.dados_globais = c.shader_data_group_with_uniform();
    u = gr.dados_globais.binding(0).get_uniform();
    u.begin();
    u.mat4x4('view');
    u.mat4x4('proj');
    u.vec2('screen_size');
    u.vec3('camera_pos');
    u.array_vec3('light_params', 3);
    u.array_vec3('light_pos', 3);
    u.array_vec3('Lamb', 3);
    u.array_vec3('Ldif', 3);
    u.array_vec3('Lspec', 3);
    u.end();
    u.proj = mat.perspective(50, c.canvas.width / c.canvas.height, 0.1, 100);
    u.view = mat.identity();
    u.screen_size = vec(c.canvas.width, c.canvas.height);
    u.camera_pos = vec(0, 0, 5);
    for (i = j = 0; j <= 2; i = ++j) {
      u.light_params[i] = phong_luzes[i].params;
      u.light_pos[i] = phong_luzes[i].pos;
      u.Lamb[i] = phong_luzes[i].Lamb;
      u.Ldif[i] = phong_luzes[i].Ldif;
      u.Lspec[i] = phong_luzes[i].Lspec;
    }
    u.gpu_send();
    // grupo de dados do material

    gr.dados_material = c.shader_data_group_with_uniform();
    u = gr.dados_material.binding(0).get_uniform();
    u.begin();
    u.vec3('Kamb');
    u.vec3('Kdif');
    u.vec3('Kspec');
    u.float('shininess');
    u.end();
    u.Kamb = phong_material.Kamb;
    u.Kdif = phong_material.Kdif;
    u.Kspec = phong_material.Kspec;
    u.shininess = phong_material.shininess;
    u.gpu_send();
    // grupo de dados para as matrizes/posicoes de cada
    // instancia. no caso, aqui a gente aloca logo
    // um uniform list suficiente pra varias instancias.

    // mas nessa implementação aqui só usaremos 1 instancia :)

    gr.dados_instancias = c.shader_data_group_with_uniform_list(100);
    u = gr.dados_instancias.binding(0).get_uniform_list();
    u.begin();
    u.mat4x4('model');
    return u.end();
  };

  prepara_instancias = function() {
    var inst, obj;
    ls = c.instance_list();
    // para renderizar as instancias, usaremos
    // o grupo global no slot 0 da gpu,
    // o grupo de material no slot 1
    // e o grupo das matrizes de cada instancia
    // no slot 2.

    ls.use_groups({
      global_index: 0,
      global_group: gr.dados_globais,
      material_index: 1,
      instance_index: 2,
      instance_group: gr.dados_instancias
    });
    // dos objetos que carregamos, pega o primeiro.
    // só carregamos um mesmo.
    obj = res.obj_by_index(0);
    // cria uma instancia pra esse objeto, usando
    // tal pipeline e tal material.
    // e define um campo de posicao pra essa instancia.

    inst = ls.instance(obj, {
      pipeline: pipe,
      material: gr.dados_material
    });
    return inst.pos = vec(0, 0, 0);
  };

  renderiza = function() {
    var R, T1, T2, inst, j, len, ref, u;
    ref = ls.instances();
    for (j = 0, len = ref.length; j < len; j++) {
      inst = ref[j];
      R = mat.rotate(angulo, 0, 1, 0);
      T1 = mat.translate(inst.pos.x, inst.pos.y, inst.pos.z);
      T2 = mat.translate(0, 0, -4);
      u = inst.get_uniform_data();
      u.model = mat.mul(T2, T1, R);
    }
    angulo += 1;
    gr.dados_instancias.gpu_send();
    job.render_begin();
    job.render_instance_list(ls);
    job.render_end();
    job.gpu_send();
    return c.animation_repeat(renderiza, 20);
  };

  if (typeof window !== 'undefined') {
    getInput = function(id) {
      return document.getElementById(id);
    };
    hex_to_vec3 = (hex) => {
      var rgb;
      rgb = hex_to_rgb(hex);
      return vec(rgb.x, rgb.y, rgb.z);
    };
    atualiza_luz_material = function() {
      var u, u2, x, y, z;
      x = parseFloat(getInput('light-x').value);
      y = parseFloat(getInput('light-y').value);
      z = parseFloat(getInput('light-z').value);
      phong_luzes[0].pos = vec(x, y, z);
      phong_material.Kamb = hex_to_vec3(getInput('ambiente').value);
      phong_material.Kdif = hex_to_vec3(getInput('difusa').value);
      phong_material.Kspec = hex_to_vec3(getInput('specular').value);
      if ((gr != null ? gr.dados_globais : void 0) && (gr != null ? gr.dados_material : void 0)) {
        u = gr.dados_globais.binding(0).get_uniform();
        u.light_pos[0] = phong_luzes[0].pos;
        u.gpu_send();
        u2 = gr.dados_material.binding(0).get_uniform();
        u2.Kamb = phong_material.Kamb;
        u2.Kdif = phong_material.Kdif;
        u2.Kspec = phong_material.Kspec;
        return u2.gpu_send();
      }
    };
    ref = ['light-x', 'light-y', 'light-z', 'ambient-color', 'diffuse-color', 'specular-color'];
    for (j = 0, len = ref.length; j < len; j++) {
      id = ref[j];
      if ((ref1 = getInput(id)) != null) {
        ref1.addEventListener('input', atualiza_luz_material);
      }
    }
  }

  main();

}).call(this);
